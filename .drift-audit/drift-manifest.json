{
  "generated": "2026-02-27T17:15:00Z",
  "project_root": "/home/tsonu/src/svap",
  "project_name": "svap",
  "summary": {
    "total_drift_areas": 14,
    "total_files_affected": 50,
    "high_impact": 6,
    "medium_impact": 6,
    "low_impact": 2,
    "by_type": {
      "structural": 7,
      "behavioral": 3,
      "semantic": 4
    },
    "evidence_coverage": {
      "high": 14,
      "medium": 0,
      "low": 0
    }
  },
  "areas": [
    {
      "id": "dead-prototype-codebase",
      "name": "Dead Prototype Codebase",
      "type": "structural",
      "description": "svap-ui-project/ is an unreferenced JSX prototype superseded by frontend/ on the same day it was committed. Contains duplicate shared UI components that have since diverged.",
      "impact": "HIGH",
      "total_files": 11,
      "variants": [
        {
          "name": "active-typescript-frontend",
          "description": "frontend/ \u2014 React 18 + TypeScript + Vite + Zustand + react-router-dom + Cognito auth. 12 views, path-based routing, granular store subscriptions.",
          "file_count": 25,
          "files": [
            "frontend/src/App.tsx",
            "frontend/src/data/pipelineStore.ts",
            "frontend/src/data/usePipelineSelectors.ts",
            "frontend/src/components/SharedUI.tsx",
            "frontend/src/views/Dashboard.tsx"
          ],
          "sample_file": "frontend/src/App.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/App.tsx",
              "start_line": 120,
              "end_line": 135,
              "snippet": "<Routes>\n  <Route path=\"/\" element={<Dashboard />} />\n  <Route path=\"/sources\" element={<SourcesView />} />\n  <Route path=\"/cases\" element={<CaseSourcing />} />\n  <Route path=\"/policies\" element={<PolicyExplorer />} />\n  ...\n</Routes>"
            }
          ],
          "implementation_details": "Production frontend with TypeScript types, Zustand state management with granular selectors, react-router-dom path-based routing, Cognito JWT authentication, and 12 views covering all pipeline stages plus management/discovery/research."
        },
        {
          "name": "dead-jsx-prototype",
          "description": "svap-ui-project/svap-ui/ \u2014 React + plain JavaScript + Context API + state-based routing. 7 views, no auth, static seed data only.",
          "file_count": 11,
          "files": [
            "svap-ui-project/svap-ui/src/App.jsx",
            "svap-ui-project/svap-ui/src/data/usePipelineData.js",
            "svap-ui-project/svap-ui/src/components/SharedUI.jsx",
            "svap-ui-project/svap-ui/src/components/Sidebar.jsx",
            "svap-ui-project/svap-ui/src/views/Dashboard.jsx"
          ],
          "sample_file": "svap-ui-project/svap-ui/src/App.jsx",
          "code_excerpts": [
            {
              "file": "svap-ui-project/svap-ui/src/App.jsx",
              "start_line": 1,
              "end_line": 10,
              "snippet": "const VIEWS = {\n  dashboard: Dashboard,\n  cases: CaseSourcing,\n  policies: PolicyExplorer,\n  ...\n};\nconst [activeView, setActiveView] = useState('dashboard');\nconst ViewComponent = VIEWS[activeView] || Dashboard;"
            }
          ],
          "implementation_details": "Initial prototype with React Context pattern, state-based view switching (no URL routing), static seed data, no authentication, 7 views. Zero commits after initial creation."
        }
      ],
      "analysis": "svap-ui-project/ was committed once (2026-02-25) and never updated. frontend/ was committed in the same initial commit and received 10+ subsequent updates. There are zero cross-references between them. The prototype's SharedUI components have diverged from frontend/'s versions (QualityTag uses static seeds vs store subscription, formatDollars relocated to utils.ts). Its continued presence inflates tooling output and creates confusion about canonical source.",
      "recommendation": "Delete svap-ui-project/ entirely (rm -rf svap-ui-project/). All 11 files are duplicated and improved in frontend/. Remove references from .gitignore if any exist. Verify no CI/CD pipelines reference the path.",
      "evidence_quality": "high",
      "status": "completed"
    },
    {
      "id": "frontend-error-loading-handling",
      "name": "Frontend Error/Loading Handling",
      "type": "behavioral",
      "description": "10 of 12 views have no error UI for async operations. Views independently create local busy state with different types (boolean vs string|null). Only ManagementView displays errors; the rest log to console.error or swallow silently.",
      "impact": "HIGH",
      "total_files": 12,
      "variants": [
        {
          "name": "no-error-ui",
          "description": "Async operations catch errors but only log to console.error() \u2014 user gets no feedback",
          "file_count": 10,
          "files": [
            "frontend/src/views/Dashboard.tsx",
            "frontend/src/views/SourcesView.tsx:44",
            "frontend/src/views/CaseSourcing.tsx",
            "frontend/src/views/TaxonomyView.tsx",
            "frontend/src/views/ConvergenceMatrix.tsx",
            "frontend/src/views/PolicyExplorer.tsx",
            "frontend/src/views/PredictionView.tsx",
            "frontend/src/views/DetectionView.tsx",
            "frontend/src/views/DiscoveryView.tsx:50-53",
            "frontend/src/views/ResearchView.tsx:64,73"
          ],
          "sample_file": "frontend/src/views/SourcesView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/SourcesView.tsx",
              "start_line": 44,
              "end_line": 44,
              "snippet": "} catch (err) { console.error(\"Upload failed:\", err); }"
            }
          ],
          "implementation_details": "Most views either have no try/catch at all (read-only views like TaxonomyView) or catch errors silently. Users see no indication when uploads, pipeline runs, or approvals fail."
        },
        {
          "name": "inline-error-panel",
          "description": "Local useState for error string, rendered as styled panel with critical color",
          "file_count": 1,
          "files": [
            "frontend/src/views/ManagementView.tsx:85-88,204-210"
          ],
          "sample_file": "frontend/src/views/ManagementView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/ManagementView.tsx",
              "start_line": 204,
              "end_line": 210,
              "snippet": "{error && (\n  <div className=\"panel stagger-in\" style={{ borderLeft: \"3px solid var(--critical)\" }}>\n    <div className=\"panel-body\" style={{ color: \"var(--critical)\" }}>\n      {error}\n    </div>\n  </div>\n)}"
            }
          ],
          "implementation_details": "ManagementView is the only view with inline error display. Uses local useState<string|null> for error, renders as a panel with critical-color left border. Uses inline styles rather than a shared error component class."
        },
        {
          "name": "global-api-gate",
          "description": "ApiGate component wraps all views, shows global loading/error from store selectors on initial load",
          "file_count": 1,
          "files": [
            "frontend/src/App.tsx:153-176"
          ],
          "sample_file": "frontend/src/App.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/App.tsx",
              "start_line": 153,
              "end_line": 176,
              "snippet": "function ApiGate({ children }) {\n  const loading = useLoading();\n  const error = useError();\n  const refresh = useRefresh();\n  // renders global loading or error overlay\n}"
            }
          ],
          "implementation_details": "Handles initial dashboard load errors only. Once the app is running, per-view async operations are not covered by this gate."
        }
      ],
      "behavior_matrix": {
        "Dashboard": {
          "local_busy": "useState<string|null>",
          "error_display": "none",
          "error_handling": "swallowed"
        },
        "SourcesView": {
          "local_busy": "useState(false)",
          "error_display": "none",
          "error_handling": "console.error"
        },
        "ManagementView": {
          "local_busy": "useState<string|null>",
          "error_display": "inline panel",
          "error_handling": "try/catch per action"
        },
        "DiscoveryView": {
          "local_busy": "useState(false)",
          "error_display": "none",
          "error_handling": "catch swallowed"
        },
        "ResearchView": {
          "local_busy": "useState(false)",
          "error_display": "none",
          "error_handling": "catch swallowed"
        },
        "DimensionRegistryView": {
          "local_busy": "useState(false)",
          "error_display": "none",
          "error_handling": "none"
        },
        "CaseSourcing": {
          "local_busy": "none",
          "error_display": "none",
          "error_handling": "none"
        },
        "TaxonomyView": {
          "local_busy": "none",
          "error_display": "none",
          "error_handling": "none"
        },
        "ConvergenceMatrix": {
          "local_busy": "none",
          "error_display": "none",
          "error_handling": "none"
        },
        "PolicyExplorer": {
          "local_busy": "none",
          "error_display": "none",
          "error_handling": "none"
        },
        "PredictionView": {
          "local_busy": "none",
          "error_display": "none",
          "error_handling": "none"
        },
        "DetectionView": {
          "local_busy": "none",
          "error_display": "none",
          "error_handling": "none"
        }
      },
      "missing_behavior_complexity": {
        "error_display": "moderate \u2014 need shared ErrorBanner component + useAsyncAction hook",
        "consistent_busy_tracking": "trivial \u2014 standardize on string|null pattern for named actions"
      },
      "analysis": "This is genuine drift. The store exports useLoading() and useError() selectors but only ApiGate uses them. Views independently create local busy state with different types. The user-visible impact is significant: failed uploads, pipeline runs, and approvals produce no feedback. ManagementView is the only view that displays errors, using an ad-hoc inline-styled panel.\n\nAlso noted by structural audit: The project built usePipelineSelectors.ts as the canonical store access layer (14 hooks), but adoption stalled at 1 of 12 views. The remaining 11 views developed 3 ad-hoc patterns organically. The useShallow pattern for data is correct; the issue is mixing data+actions in useShallow (unnecessary overhead) and having multiple access patterns without a clear convention. New views have no template to follow.\n\nAlso noted by structural audit: The project has a well-structured CSS system with custom properties and utility classes, but 7 views bypass it with inline styles. Most are for common layout patterns (flex row with gap, flex wrap) that appear repeatedly across views. Creating new objects on every render is a minor perf concern but mainly it's a consistency issue \u2014 some views are pure CSS classes, others mix in inline styles. CSS variable injection via inline style is the correct React pattern for dynamic theming and should not change.",
      "recommendation": "Migrate SourcesView.SourceRow to useAsyncAction for upload/delete operations. Migrate ManagementView to useAsyncAction, replacing its 5 manual busy/error/try/catch patterns.",
      "evidence_quality": "high",
      "status": "completed",
      "merged_from": [
        "frontend-store-access-patterns",
        "frontend-inline-styles"
      ],
      "reaudit_note": "2026-02-28: Core infrastructure (useAsyncAction + ErrorBanner) is in place. Dashboard, DiscoveryView, ResearchView fully adopted. SourcesView.SourceRow (upload/delete) and ManagementView (5 async ops) still use console.error instead of the shared pattern."
    },
    {
      "id": "backend-config-duplication",
      "name": "Backend Config Duplication",
      "type": "structural",
      "description": "Identical default configuration dict exists in both api.py (_DEFAULT_CONFIG) and stage_runner.py (_default_config()). Must be updated in two places when defaults change.",
      "impact": "MEDIUM",
      "total_files": 2,
      "variants": [
        {
          "name": "module-level-dict",
          "description": "_DEFAULT_CONFIG as module-level dict in api.py \u2014 shared mutable reference",
          "file_count": 1,
          "files": [
            "backend/src/svap/api.py:52-72"
          ],
          "sample_file": "backend/src/svap/api.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/api.py",
              "start_line": 52,
              "end_line": 72,
              "snippet": "_DEFAULT_CONFIG = {\n    \"bedrock\": {\n        \"region\": \"us-east-1\",\n        \"model_id\": \"us.anthropic.claude-sonnet-4-6\",\n        \"max_tokens\": 4096,\n        \"temperature\": 0.2,\n        \"retry_attempts\": 3,\n        \"retry_delay_seconds\": 5,\n    },\n    \"rag\": { ... },\n    \"pipeline\": { ... },\n}"
            }
          ],
          "implementation_details": "Module-level dict. Used as dict(_DEFAULT_CONFIG) when needed (shallow copy). Mutable \u2014 could be accidentally modified at runtime."
        },
        {
          "name": "factory-function",
          "description": "_default_config() factory function in stage_runner.py \u2014 returns fresh dict each call",
          "file_count": 1,
          "files": [
            "backend/src/svap/stage_runner.py:134-156"
          ],
          "sample_file": "backend/src/svap/stage_runner.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/stage_runner.py",
              "start_line": 134,
              "end_line": 156,
              "snippet": "def _default_config() -> dict:\n    \"\"\"Minimal default config when no config file is available.\"\"\"\n    return {\n        \"bedrock\": {\n            \"region\": \"us-east-1\",\n            \"model_id\": \"us.anthropic.claude-sonnet-4-6\",\n            ...\n        },\n        ...\n    }"
            }
          ],
          "implementation_details": "Factory function returning fresh dict. Safer pattern (no shared mutable state) but duplicates all values from api.py."
        }
      ],
      "analysis": "Both files contain identical configuration values today. They diverged in form (dict vs function) but not content. The risk is future desynchronization \u2014 if the model ID or retry parameters change, both must be updated independently. The factory function pattern in stage_runner.py is safer (returns fresh dict), but having two sources of truth for defaults is unnecessary given they're in the same Python package.\n\nAlso noted by structural audit: These two functions have identical control flow \u2014 load from S3 if CONFIG_BUCKET is set, else load from local file, fall back to defaults, apply overrides. The only difference is import style (lazy vs top-level) and a minor variable naming difference (inline vs named s3 client). This is exactly the pattern the backend-config-duplication area solved for default values \u2014 the loading logic was left behind. If config loading needs to change (e.g., adding caching, changing the S3 key, supporting SSM parameter store), both files must be updated independently.",
      "recommendation": "Extract to svap/defaults.py: def default_config() -> dict. Both api.py and stage_runner.py import from this single source. Use the factory function pattern (fresh dict per call).",
      "evidence_quality": "high",
      "status": "completed",
      "merged_from": [
        "backend-config-loading-duplication"
      ]
    },
    {
      "id": "parallel-execution-duplication",
      "name": "Parallel LLM Execution Duplication",
      "type": "semantic",
      "description": "Stages 5 and 6 each have a nearly identical _run_parallel_* function that creates a ThreadPoolExecutor, submits LLM calls, collects results via as_completed, counts successes, and tracks failures. Only variable names and store functions differ.",
      "impact": "MEDIUM",
      "total_files": 2,
      "variants": [
        {
          "name": "run-parallel-predictions",
          "description": "_run_parallel_predictions() in stage5 \u2014 submits prediction LLM calls, stores via _store_predictions",
          "file_count": 1,
          "files": [
            "backend/src/svap/stages/stage5_prediction.py:104-131"
          ],
          "sample_file": "backend/src/svap/stages/stage5_prediction.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/stages/stage5_prediction.py",
              "start_line": 104,
              "end_line": 126,
              "snippet": "def _run_parallel_predictions(storage, client, run_id, jobs, max_concurrency):\n    total_predictions = 0\n    failed_policies = []\n    with ThreadPoolExecutor(max_workers=max_concurrency) as executor:\n        future_to_policy = {\n            executor.submit(_invoke_llm, client, prompt): (policy_id, profile, h)\n            for policy_id, profile, h, prompt in jobs\n        }\n        for future in as_completed(future_to_policy):\n            policy_id, profile, h = future_to_policy[future]\n            try:\n                result = future.result()\n                count = _store_predictions(storage, run_id, policy_id, profile, result)\n                total_predictions += count\n            except Exception as exc:\n                failed_policies.append(policy_id)\n                print(f\"  ERROR for {policy_id}: {exc}\")\n    return total_predictions, failed_policies"
            }
          ],
          "implementation_details": "Jobs are (policy_id, profile, hash, prompt) tuples. Result stored via _store_predictions(). Failures tracked by policy_id. Returns (total_predictions, failed_policies)."
        },
        {
          "name": "run-parallel-detection",
          "description": "_run_parallel_detection() in stage6 \u2014 submits detection LLM calls, stores via _store_patterns",
          "file_count": 1,
          "files": [
            "backend/src/svap/stages/stage6_detection.py:98-125"
          ],
          "sample_file": "backend/src/svap/stages/stage6_detection.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/stages/stage6_detection.py",
              "start_line": 98,
              "end_line": 120,
              "snippet": "def _run_parallel_detection(storage, client, run_id, jobs, max_concurrency):\n    total_patterns = 0\n    failed_predictions = []\n    with ThreadPoolExecutor(max_workers=max_concurrency) as executor:\n        future_to_pred = {\n            executor.submit(_invoke_llm, client, prompt): (pred, h)\n            for pred, h, prompt in jobs\n        }\n        for future in as_completed(future_to_pred):\n            pred, h = future_to_pred[future]\n            try:\n                result = future.result()\n                count = _store_patterns(storage, run_id, pred, result)\n                total_patterns += count\n            except Exception as exc:\n                failed_predictions.append(pred[\"prediction_id\"])\n                print(f\"  ERROR for {pred['prediction_id']}: {exc}\")\n    return total_patterns, failed_predictions"
            }
          ],
          "implementation_details": "Jobs are (pred, hash, prompt) tuples. Result stored via _store_patterns(). Failures tracked by prediction_id. Returns (total_patterns, failed_predictions)."
        }
      ],
      "analysis": "This is textbook semantic duplication \u2014 the same functional concept ('execute LLM calls in parallel, store results, track failures') implemented twice with different variable names. The functions share identical control flow: ThreadPoolExecutor creation, future submission via _invoke_llm, as_completed iteration, try/except per future, success counting, failure tracking, and tuple return. The only meaningful differences are the job tuple shape and the store callback. This likely arose from copy-paste when stage6 was built from stage5.",
      "recommendation": "Extract a generic run_parallel_llm() utility to svap/parallel.py parameterized by (client, jobs, store_fn, max_concurrency). Interface: run_parallel_llm(client: BedrockClient, jobs: list[tuple], store_fn: Callable, max_concurrency: int, label: str) -> tuple[int, list[str]]. Both stages call this with their specific store function.",
      "evidence_quality": "high",
      "status": "completed"
    },
    {
      "id": "backend-route-error-handling",
      "name": "Backend API Route Error Handling",
      "type": "behavioral",
      "description": "API routes use 3 different strategies for missing data: strict 404 via get_active_run_id(), graceful fallback via get_latest_run() or empty string, and unguarded path parameter access that could produce raw 500 errors.",
      "impact": "LOW",
      "total_files": 1,
      "variants": [
        {
          "name": "strict-404",
          "description": "Routes call get_active_run_id() which raises ApiError(404) if no active run exists",
          "file_count": 1,
          "files": [
            "backend/src/svap/api.py"
          ],
          "sample_file": "backend/src/svap/api.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/api.py",
              "start_line": 113,
              "end_line": 120,
              "snippet": "def get_active_run_id(storage):\n    run_id = storage.get_latest_run()\n    if not run_id:\n        raise ApiError(404, \"No active pipeline run\")\n    return run_id"
            }
          ],
          "implementation_details": "Used by /api/status and resource-specific endpoints. Correct for endpoints that require an active run."
        },
        {
          "name": "graceful-fallback",
          "description": "Routes use get_latest_run() or empty string \u2014 returns empty/default data instead of 404",
          "file_count": 1,
          "files": [
            "backend/src/svap/api.py"
          ],
          "sample_file": "backend/src/svap/api.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/api.py",
              "start_line": 1,
              "end_line": 5,
              "snippet": "def _dashboard(event):\n    storage = get_storage()\n    run_id = storage.get_latest_run() or \"\"\n    return get_dashboard_data(storage, run_id)"
            }
          ],
          "implementation_details": "Used by /api/dashboard. Correct for the dashboard which should render even with no runs."
        },
        {
          "name": "unguarded-path-params",
          "description": "Direct event['pathParameters']['param'] access without .get() fallback",
          "file_count": 1,
          "files": [
            "backend/src/svap/api.py"
          ],
          "sample_file": "backend/src/svap/api.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/api.py",
              "start_line": 1,
              "end_line": 3,
              "snippet": "def _get_case(event):\n    case_id = event[\"pathParameters\"][\"case_id\"]  # Could KeyError"
            }
          ],
          "implementation_details": "If API Gateway malforms the event, this raises KeyError which becomes a raw 500 instead of ApiError(400). Should use .get() with a guard."
        }
      ],
      "behavior_matrix": {
        "_status": {
          "missing_run": "ApiError(404)",
          "path_params": "n/a"
        },
        "_dashboard": {
          "missing_run": "empty data",
          "path_params": "n/a"
        },
        "_get_case": {
          "missing_run": "n/a",
          "path_params": "direct dict access (KeyError risk)"
        }
      },
      "analysis": "The strict-404 vs graceful-fallback distinction is intentional and correct \u2014 the dashboard should work without runs, but /api/status should not. The actual bug is the unguarded path parameter access which could produce a raw 500 error instead of a proper 400. This is LOW impact because API Gateway validates path parameters before the Lambda runs, so the KeyError would only occur with a malformed test event.",
      "recommendation": "Add a _path_param(event, name) helper that extracts with .get() and raises ApiError(400) on missing. Use it in all path-parameterized routes.",
      "evidence_quality": "high",
      "status": "completed"
    },
    {
      "id": "frontend-auth-token-access",
      "name": "Frontend Auth Token Access",
      "type": "structural",
      "description": "ManagementView builds its own auth headers helper and calls fetch() directly, while all other views use the Zustand store's apiGet/apiPost which handle auth centrally.",
      "impact": "LOW",
      "total_files": 2,
      "variants": [
        {
          "name": "store-centralized-auth",
          "description": "API calls go through pipelineStore's apiGet()/apiPost() which handle Authorization header",
          "file_count": 11,
          "files": [
            "frontend/src/data/pipelineStore.ts:38-49"
          ],
          "sample_file": "frontend/src/data/pipelineStore.ts",
          "code_excerpts": [
            {
              "file": "frontend/src/data/pipelineStore.ts",
              "start_line": 38,
              "end_line": 49,
              "snippet": "async function apiPost(path: string, body?: unknown): Promise<unknown> {\n  const token = await getToken();\n  const headers: Record<string, string> = {};\n  if (body !== undefined) headers[\"Content-Type\"] = \"application/json\";\n  if (token) headers[\"Authorization\"] = `Bearer ${token}`;\n  // ...\n}"
            }
          ],
          "implementation_details": "apiGet and apiPost are module-scoped functions in pipelineStore.ts. They handle token retrieval, header construction, and JSON parsing. All store actions use these."
        },
        {
          "name": "direct-fetch-with-local-auth",
          "description": "ManagementView creates its own authHeaders() helper and calls fetch() directly",
          "file_count": 1,
          "files": [
            "frontend/src/views/ManagementView.tsx:90-93"
          ],
          "sample_file": "frontend/src/views/ManagementView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/ManagementView.tsx",
              "start_line": 90,
              "end_line": 93,
              "snippet": "const authHeaders = async (): Promise<Record<string, string>> => {\n  const token = await getToken();\n  return token ? { Authorization: `Bearer ${token}` } : {};\n};"
            }
          ],
          "implementation_details": "Used for management-specific endpoints (/api/management/executions, /api/management/runs, stop/delete actions) that aren't wired through the Zustand store."
        }
      ],
      "analysis": "ManagementView accesses admin endpoints that don't fit the pipeline store's data model (executions, run management). Rather than adding these to the store, it built its own fetch+auth layer. This is pragmatic but creates a second auth code path. If token refresh logic changes in pipelineStore, ManagementView's authHeaders() would need a parallel update.",
      "recommendation": "Extract apiGet/apiPost from pipelineStore.ts into a standalone api.ts utility module. Both the store and ManagementView import from this shared module. Interface: export async function apiGet(path: string): Promise<unknown>; export async function apiPost(path: string, body?: unknown): Promise<unknown>;",
      "evidence_quality": "high",
      "status": "completed",
      "reaudit_note": "2026-02-28: Fully resolved. api.ts extracted, ManagementView migrated, useStatusSubscription.ts migrated to apiGet (imports from data/api.ts, line 15). Zero files now bypass the shared API utility."
    },
    {
      "id": "dead-pipeline-prototype",
      "name": "Dead Pipeline Prototype",
      "type": "structural",
      "description": "svap_pipeline/ is a SQLite-based CLI prototype of the backend, committed once in the initial commit (2026-02-25) and never updated. It duplicates the entire pipeline (stages 1-6, orchestrator, storage) but uses SQLite instead of PostgreSQL, has no Lambda/Step Functions support, and lacks stages 0, 0A, 4A, 4B, 4C that were added later. Zero cross-references from the active codebase.",
      "impact": "HIGH",
      "total_files": 30,
      "variants": [
        {
          "name": "active-backend",
          "description": "backend/src/svap/ \u2014 PostgreSQL + Lambda + Step Functions. 11 stages, delta processing, parallel execution, Cognito auth.",
          "file_count": 20,
          "files": [
            "backend/src/svap/api.py",
            "backend/src/svap/stage_runner.py",
            "backend/src/svap/orchestrator.py",
            "backend/src/svap/storage.py",
            "backend/src/svap/defaults.py"
          ],
          "sample_file": "backend/src/svap/storage.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/storage.py",
              "start_line": 1,
              "end_line": 5,
              "snippet": "# PostgreSQL storage with 2221 lines, full CRUD,\n# schema auto-migration, connection pooling"
            }
          ],
          "implementation_details": "Production backend with PostgreSQL, Lambda handlers, Step Functions integration, delta processing, and 11 stage implementations."
        },
        {
          "name": "dead-sqlite-prototype",
          "description": "svap_pipeline/svap/ \u2014 SQLite + CLI-only. 6 stages (1-6), no auth, no cloud deployment.",
          "file_count": 30,
          "files": [
            "svap_pipeline/svap/svap/storage.py",
            "svap_pipeline/svap/svap/orchestrator.py",
            "svap_pipeline/svap/config.yaml",
            "svap_pipeline/svap/svap/bedrock_client.py"
          ],
          "sample_file": "svap_pipeline/svap/config.yaml",
          "code_excerpts": [
            {
              "file": "svap_pipeline/svap/config.yaml",
              "start_line": 1,
              "end_line": 3,
              "snippet": "storage:\n  db_path: ./svap_data.db  # SQLite database file"
            }
          ],
          "implementation_details": "Initial proof-of-concept with SQLite, CLI orchestrator, 6 stages. 518-line storage.py vs 2221-line production version. No Lambda, no Step Functions, no auth."
        }
      ],
      "analysis": "Identical pattern to the previously-deleted svap-ui-project/: a prototype committed in the initial commit that was immediately superseded by the production architecture. Contains 30 tracked files that inflate tooling output. The prototype's storage.py (518 lines, SQLite) has completely diverged from the production storage.py (2221 lines, PostgreSQL). Zero imports or references from anywhere in the active codebase.",
      "recommendation": "Delete svap_pipeline/ entirely (rm -rf svap_pipeline/). All 30 files \u2014 stages, orchestrator, storage, config \u2014 exist and are vastly improved in backend/src/svap/. Verify no scripts or documentation reference svap_pipeline/ paths before deleting.",
      "evidence_quality": "high",
      "status": "completed"
    },
    {
      "id": "eslint-rules-duplication",
      "name": "ESLint Rules Directory Duplication",
      "type": "structural",
      "description": "ESLint rule files exist in two directories: eslint-rules/ (project root, drift-generated) and frontend/eslint-rules/ (actively used). The root rules are orphaned \u2014 nothing imports them. Two overlapping rules (max-jsx-props, no-inline-styles) have diverged: the root no-inline-styles has a smarter CSS custom property allowance that the frontend version lacks.",
      "impact": "HIGH",
      "total_files": 7,
      "variants": [
        {
          "name": "root-drift-generated",
          "description": "eslint-rules/ at project root \u2014 3 rules marked // drift-generated, NOT imported anywhere",
          "file_count": 3,
          "files": [
            "eslint-rules/max-jsx-props.js",
            "eslint-rules/no-escape-hatches.js",
            "eslint-rules/no-inline-styles.js"
          ],
          "sample_file": "eslint-rules/no-inline-styles.js",
          "code_excerpts": [
            {
              "file": "eslint-rules/no-inline-styles.js",
              "start_line": 59,
              "end_line": 80,
              "snippet": "function isCustomPropertiesOnly(node) {\n  // Allows style={{ '--q-color': quality.color }}\n  // which is the correct React pattern for CSS custom properties\n  ...\n}"
            }
          ],
          "implementation_details": "Has smarter no-inline-styles with CSS custom property allowance (81 lines). Also has no-escape-hatches rule (86 lines) that frontend doesn't have. Drift config sync points here but nothing uses these."
        },
        {
          "name": "frontend-active",
          "description": "frontend/eslint-rules/ \u2014 4 rules imported by frontend/eslint.config.js",
          "file_count": 4,
          "files": [
            "frontend/eslint-rules/max-jsx-props.js",
            "frontend/eslint-rules/no-inline-styles.js",
            "frontend/eslint-rules/no-direct-fetch.js",
            "frontend/eslint-rules/no-direct-store-import.js"
          ],
          "sample_file": "frontend/eslint-rules/no-inline-styles.js",
          "code_excerpts": [
            {
              "file": "frontend/eslint-rules/no-inline-styles.js",
              "start_line": 1,
              "end_line": 5,
              "snippet": "// Blanket bans ALL inline styles without exception\n// 39 lines \u2014 missing CSS custom property allowance from root version"
            }
          ],
          "implementation_details": "Simpler no-inline-styles (39 lines, blanket ban). Has no-direct-fetch and no-direct-store-import (unique to frontend). Missing no-escape-hatches entirely. These are the actually-wired rules."
        }
      ],
      "analysis": "The drift-guard phase of the previous cycle generated rules to eslint-rules/ (matching the drift config's sync path), but the frontend's ESLint config imports from frontend/eslint-rules/. This disconnect means the drift-generated rules were never actually enforced. Worse, the frontend's no-inline-styles is a degraded version that flags legitimate CSS custom property usage (var(--q-color) patterns), producing false positives that views must suppress with eslint-disable comments.",
      "recommendation": "1. Consolidate to frontend/eslint-rules/ as the single canonical location. 2. Upgrade frontend no-inline-styles.js with the root version's custom property allowance. 3. Copy no-escape-hatches.js to frontend/eslint-rules/ and wire it. 4. Delete eslint-rules/ at root. 5. Update .drift-audit/config.json sync path to frontend/eslint-rules/.",
      "evidence_quality": "high",
      "status": "completed"
    },
    {
      "id": "backend-logging-inconsistency",
      "name": "Backend Logging Inconsistency",
      "type": "structural",
      "description": "All 11 stage files use print() for output (129 calls total) while api.py and stage_runner.py use Python's logging module. In Lambda, print() goes to stdout without timestamps or severity levels; logging integrates with CloudWatch structured logs.",
      "impact": "MEDIUM",
      "total_files": 13,
      "variants": [
        {
          "name": "logging-module",
          "description": "api.py and stage_runner.py use logging.getLogger(__name__) with logger.info/warning/error",
          "file_count": 2,
          "files": [
            "backend/src/svap/api.py",
            "backend/src/svap/stage_runner.py"
          ],
          "sample_file": "backend/src/svap/api.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/api.py",
              "start_line": 1,
              "end_line": 3,
              "snippet": "logger = logging.getLogger(__name__)\nlogger.info(\"Gate registered for run_id=%s stage=%s\", run_id, stage)"
            }
          ],
          "implementation_details": "Structured logging with severity levels, module context, and format strings. Integrates with CloudWatch Logs when running in Lambda."
        },
        {
          "name": "print-statements",
          "description": "All stage files (stage0 through stage6, plus stage0a, stage4a-c) use print() exclusively",
          "file_count": 11,
          "files": [
            "backend/src/svap/stages/stage0_source_fetch.py",
            "backend/src/svap/stages/stage0a_discovery.py",
            "backend/src/svap/stages/stage1_case_assembly.py",
            "backend/src/svap/stages/stage2_taxonomy.py",
            "backend/src/svap/stages/stage3_scoring.py",
            "backend/src/svap/stages/stage4_scanning.py",
            "backend/src/svap/stages/stage4a_triage.py",
            "backend/src/svap/stages/stage4b_research.py",
            "backend/src/svap/stages/stage4c_assessment.py",
            "backend/src/svap/stages/stage5_prediction.py",
            "backend/src/svap/stages/stage6_detection.py"
          ],
          "sample_file": "backend/src/svap/stages/stage1_case_assembly.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/stages/stage1_case_assembly.py",
              "start_line": 1,
              "end_line": 3,
              "snippet": "print(\"Stage 1: Case Corpus Assembly\")\nprint(f\"  Skipping (cases exist): {doc['filename']}\")\nprint(f\"  ERROR for {doc['filename']}: {exc}\")"
            }
          ],
          "implementation_details": "129 print() calls across 11 files. No timestamps, no severity levels, no module context. Errors printed with print(f'  ERROR...') rather than logger.error(). Makes production debugging in CloudWatch significantly harder."
        }
      ],
      "analysis": "This drift likely arose because the stages were originally developed as CLI scripts (see svap_pipeline/ prototype) where print() was natural. When they were integrated into the Lambda architecture, the Lambda handlers (api.py, stage_runner.py) adopted logging but the stage implementations were never migrated. The impact is real: CloudWatch Logs from stage execution lack structured severity, timestamps, and module context that aid production debugging.\n\nAlso noted by structural audit: The per-call parameter values likely reflect prompt engineering requirements \u2014 stage0's 500 tokens for simple validation vs stage4a's 8192 for detailed triage. These are intentional but unmanageable: changing a stage's token budget requires a code edit, and there's no visibility into the current parameter landscape without reading all 11 files. Stage 5's unique temperature=0.3 is undocumented. Additionally, stages 0A and 4B read config sections ('discovery', 'research') not defined in defaults.py, making them invisible to developers.",
      "recommendation": "Add `logger = logging.getLogger(__name__)` to each stage file. Replace print() with logger.info(), print('  ERROR...') with logger.error(). This is mechanical \u2014 a regex replacement with minor manual review for severity levels.",
      "evidence_quality": "high",
      "status": "completed",
      "merged_from": [
        "backend-llm-config-hardcoding"
      ]
    },
    {
      "id": "frontend-empty-state-handling",
      "name": "Frontend Empty State Handling",
      "type": "behavioral",
      "description": "Empty state handling is inconsistent across views: CaseSourcing and TaxonomyView render blank space when data is empty (no empty state message). Other views use 'empty-state' class but vary in placement (td-in-tbody vs div-replacing-table) and text style (periods vs no periods, actionable vs passive).",
      "impact": "MEDIUM",
      "total_files": 8,
      "variants": [
        {
          "name": "no-empty-state",
          "description": "Views that render nothing when data arrays are empty",
          "file_count": 2,
          "files": [
            "frontend/src/views/CaseSourcing.tsx:112-120",
            "frontend/src/views/TaxonomyView.tsx:101-109"
          ],
          "sample_file": "frontend/src/views/CaseSourcing.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/CaseSourcing.tsx",
              "start_line": 112,
              "end_line": 115,
              "snippet": "<tbody>\n  {cases.map((c) => (\n    <CaseRow key={c.case_id} ... />\n  ))}\n</tbody>\n// No empty state fallback \u2014 renders empty <tbody>"
            }
          ],
          "implementation_details": "cases.map() and taxonomy.map() produce no output when arrays are empty. User sees an empty table body or empty quality grid with no explanation."
        },
        {
          "name": "td-empty-state",
          "description": "Empty state as <td colSpan> inside <tbody> \u2014 keeps table structure intact",
          "file_count": 1,
          "files": [
            "frontend/src/views/SourcesView.tsx:267-271"
          ],
          "sample_file": "frontend/src/views/SourcesView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/SourcesView.tsx",
              "start_line": 267,
              "end_line": 271,
              "snippet": "<td colSpan={6} className=\"empty-state\">No enforcement sources configured. Add a source to get started.</td>"
            }
          ],
          "implementation_details": "Keeps the table header visible, shows message inside table body. Actionable text with period."
        },
        {
          "name": "div-empty-state",
          "description": "Empty state as <div> replacing the table entirely",
          "file_count": 5,
          "files": [
            "frontend/src/views/DiscoveryView.tsx:108-110",
            "frontend/src/views/DiscoveryView.tsx:164-166",
            "frontend/src/views/ResearchView.tsx:126-128",
            "frontend/src/views/ResearchView.tsx:170-172",
            "frontend/src/views/DimensionRegistryView.tsx:58-61"
          ],
          "sample_file": "frontend/src/views/DiscoveryView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/DiscoveryView.tsx",
              "start_line": 108,
              "end_line": 110,
              "snippet": "<div className=\"empty-state\">No feeds configured.</div>"
            }
          ],
          "implementation_details": "Replaces the entire table/list with a div. Text style varies: 'No feeds configured.' (period) vs 'No executions found' (no period). Some include actionable guidance, some don't."
        }
      ],
      "behavior_matrix": {
        "CaseSourcing": {
          "empty_state": "none",
          "placement": "n/a",
          "text_style": "n/a"
        },
        "TaxonomyView": {
          "empty_state": "none",
          "placement": "n/a",
          "text_style": "n/a"
        },
        "SourcesView": {
          "empty_state": "present",
          "placement": "td-in-tbody",
          "text_style": "actionable, period"
        },
        "DiscoveryView": {
          "empty_state": "present",
          "placement": "div-replacing",
          "text_style": "mixed"
        },
        "ResearchView": {
          "empty_state": "present",
          "placement": "div-replacing",
          "text_style": "actionable, period"
        },
        "DimensionRegistryView": {
          "empty_state": "present",
          "placement": "div-in-grid",
          "text_style": "actionable, period"
        },
        "ManagementView": {
          "empty_state": "present",
          "placement": "div-in-panel",
          "text_style": "passive, no period"
        }
      },
      "analysis": "The missing empty states in CaseSourcing and TaxonomyView are the most visible issue \u2014 users see an empty table or grid with column headers but no indication that data is expected. The placement variance (td vs div) is less critical but creates visual inconsistency. Text style variance suggests no shared empty state component or convention.\n\nAlso noted by behavioral audit: The split is clean: all div-based expandables have accessibility, all tr-based expandables don't. This suggests the accessibility pattern was established for the newer div-based components but was never backported to the table-row pattern. The fix is straightforward: add tabIndex={0} and onKeyDown to the three <tr> elements.",
      "recommendation": "1. Add empty state messages to CaseSourcing and TaxonomyView. 2. Standardize on the div-replacing pattern (which is most common). 3. Standardize text to be actionable with period: 'No X found. Run Y to get started.' 4. Consider an EmptyState component in SharedUI.tsx.",
      "evidence_quality": "high",
      "status": "completed",
      "merged_from": [
        "frontend-expandable-accessibility"
      ]
    },
    {
      "id": "backend-utility-print-statements",
      "name": "Backend Utility Print Statements",
      "type": "structural",
      "description": "Three core utility files (parallel.py, storage.py, bedrock_client.py) still use print() for output while all 11 stage files and both Lambda handlers use the logging module. These files were outside the scope of the original logging unification which targeted stage files only.",
      "impact": "MEDIUM",
      "total_files": 3,
      "variants": [
        {
          "name": "logging-module",
          "description": "All 11 stage files + api.py + stage_runner.py use logger = logging.getLogger(__name__)",
          "file_count": 13,
          "files": [
            "backend/src/svap/api.py:1-20",
            "backend/src/svap/stage_runner.py:1-20",
            "backend/src/svap/stages/stage0_source_fetch.py:1-10",
            "backend/src/svap/stages/stage1_case_assembly.py:1-10",
            "backend/src/svap/stages/stage2_taxonomy.py:1-10"
          ],
          "sample_file": "backend/src/svap/api.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/api.py",
              "start_line": 18,
              "end_line": 18,
              "snippet": "logger = logging.getLogger(__name__)"
            }
          ],
          "implementation_details": "Structured logging with severity levels, module context, and format strings. Integrates with CloudWatch Logs in Lambda."
        },
        {
          "name": "print-statements",
          "description": "Utility files use print() \u2014 parallel.py (4 calls), storage.py (4 calls), bedrock_client.py (1 call)",
          "file_count": 3,
          "files": [
            "backend/src/svap/parallel.py:24-45",
            "backend/src/svap/storage.py:57-134",
            "backend/src/svap/bedrock_client.py:76-78"
          ],
          "sample_file": "backend/src/svap/parallel.py",
          "code_excerpts": [
            {
              "file": "backend/src/svap/parallel.py",
              "start_line": 24,
              "end_line": 24,
              "snippet": "print(f\"  Submitting {len(jobs)} parallel Bedrock calls (concurrency={max_concurrency})...\")"
            },
            {
              "file": "backend/src/svap/bedrock_client.py",
              "start_line": 76,
              "end_line": 78,
              "snippet": "print(\n    f\"  Bedrock call failed (attempt {attempt + 1}): {e}. Retrying in {wait}s...\"\n)"
            },
            {
              "file": "backend/src/svap/storage.py",
              "start_line": 125,
              "end_line": 125,
              "snippet": "print(f\"  Migration: applying v{version} ({len(statements)} statements)\")"
            }
          ],
          "implementation_details": "9 total print() calls across 3 files. parallel.py prints progress/failures, storage.py prints migration status, bedrock_client.py prints retry warnings. All are called from Lambda context where print() lacks CloudWatch structured fields."
        }
      ],
      "analysis": "The original backend-logging-inconsistency area (now completed) targeted the 11 stage files, replacing 129 print() calls. These 3 utility files were outside that scope. They are called from Lambda via stage_runner.py and api.py, so their print() output goes to CloudWatch without timestamps, severity, or module context. The bedrock_client retry message is particularly problematic \u2014 it should be logger.warning() to appear in error dashboards. storage.py's migration prints are less critical (run once per cold start) but should still be logger.info() for consistency. Note: orchestrator.py and dev_server.py print() is intentional \u2014 they're CLI tools, not Lambda code.",
      "recommendation": "Add `import logging; logger = logging.getLogger(__name__)` to parallel.py, storage.py, and bedrock_client.py. Replace print() with logger.info() for status messages, logger.warning() for failures/retries, and logger.error() for errors. Exclude storage.py line 57 (sys.exit path) which is CLI-only.",
      "evidence_quality": "high",
      "status": "completed"
    },
    {
      "id": "view-scaffold-duplication",
      "name": "View Scaffold Duplication",
      "type": "semantic",
      "description": "Semantic cluster-001 (similarity 0.42) identifies 5 async-action views that repeat an identical scaffold: view-header with title/description, ErrorBanner, inline MetricsRow component, panel containers with action buttons, data tables with expandable rows. Each view re-implements the same structural template with ~300 lines of boilerplate, totaling ~1500 lines of semantic duplication across 5 files. MetricsRow alone is defined as a fresh inline component in each file despite identical structure (metrics-row CSS grid \u2192 metric-card children). The scaffold was never extracted because each view was built incrementally.",
      "impact": "HIGH",
      "total_files": 5,
      "variants": [
        {
          "name": "dashboard-scaffold",
          "description": "Dashboard.tsx \u2014 view-header + MetricsRow (4 metrics) + PipelineControls + split-view with 2 tables",
          "file_count": 1,
          "files": [
            "frontend/src/views/Dashboard.tsx:1-283"
          ],
          "sample_file": "frontend/src/views/Dashboard.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/Dashboard.tsx",
              "start_line": 216,
              "end_line": 230,
              "snippet": "return (\n  <div>\n    <div className=\"view-header stagger-in\">\n      <h2>Structural Vulnerability Analysis</h2>\n      <div className=\"view-desc\">...</div>\n    </div>\n    <ErrorBanner error={error} onDismiss={clearError} />\n    <MetricsRow ... />\n    <PipelineControls busy={busy} run={run} />\n    <div className=\"split-view\">\n      <HighRiskTable ... />\n      <TopCasesTable ... />\n    </div>\n  </div>\n)"
            }
          ],
          "implementation_details": "4 inline sub-components (MetricsRow, HighRiskTable, TopCasesTable, PipelineControls). Metrics computed inline from store selectors. Action buttons use run('key', fn) pattern. No useEffect \u2014 data pre-loaded."
        },
        {
          "name": "discovery-scaffold",
          "description": "DiscoveryView.tsx \u2014 same scaffold + filter bar + 2 panels (feeds table, candidates panel)",
          "file_count": 1,
          "files": [
            "frontend/src/views/DiscoveryView.tsx:1-282"
          ],
          "sample_file": "frontend/src/views/DiscoveryView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/DiscoveryView.tsx",
              "start_line": 63,
              "end_line": 75,
              "snippet": "const { busy, error, run, clearError } = useAsyncAction();\n// ... identical scaffold pattern\nconst feedCount = source_feeds.length;\nconst candidateCount = source_candidates.length;\nconst reviewCount = source_candidates.filter((c) => c.status === 'scored').length;\nconst acceptedCount = source_candidates.filter((c) => c.status === 'accepted').length;"
            }
          ],
          "implementation_details": "4 inline sub-components (DiscoveryMetrics, FeedsTable, CandidatesPanel, CandidateRow). Metrics computed as .filter().length inline. useEffect fetches on mount. Filter state: useState<string|null> for candidate status."
        },
        {
          "name": "management-scaffold",
          "description": "ManagementView.tsx \u2014 same scaffold + 2 panels (executions, runs) with per-item async actions",
          "file_count": 1,
          "files": [
            "frontend/src/views/ManagementView.tsx:1-310"
          ],
          "sample_file": "frontend/src/views/ManagementView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/ManagementView.tsx",
              "start_line": 241,
              "end_line": 260,
              "snippet": "return (\n  <div>\n    <div className=\"view-header stagger-in\">\n      <h2>Pipeline Management</h2>\n      <div className=\"view-desc\">...</div>\n    </div>\n    <ErrorBanner error={error} onDismiss={clearError} />\n    <ManagementMetrics runningCount={runningCount} totalRuns={runs.length} />\n    <ExecutionsPanel ... />\n    <RunsPanel ... />\n  </div>\n)"
            }
          ],
          "implementation_details": "3 inline sub-components (ManagementMetrics, ExecutionsPanel, RunsPanel). Uses confirm() for destructive actions. Per-item busy tracking (busy === arn). useEffect fetches executions + runs on mount."
        },
        {
          "name": "research-scaffold",
          "description": "ResearchView.tsx \u2014 same scaffold + triage table + sessions panel with async-on-expand",
          "file_count": 1,
          "files": [
            "frontend/src/views/ResearchView.tsx:1-322"
          ],
          "sample_file": "frontend/src/views/ResearchView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/ResearchView.tsx",
              "start_line": 264,
              "end_line": 280,
              "snippet": "return (\n  <div>\n    <div className=\"view-header stagger-in\">\n      <h2>Deep Research</h2>\n      <div className=\"view-desc\">...</div>\n    </div>\n    <ErrorBanner error={error} onDismiss={clearError} />\n    <ResearchMetrics ... />\n    <div className=\"panel stagger-in\">...</div>\n    <SessionsPanel ... />\n  </div>\n)"
            }
          ],
          "implementation_details": "5 inline sub-components (TriageTable, SessionDetail, ResearchMetrics, SessionCard, SessionsPanel). Async data fetch on expand (Promise.all for findings + assessments). useEffect fetches triage + sessions on mount."
        },
        {
          "name": "sources-scaffold",
          "description": "SourcesView.tsx \u2014 same scaffold + source table with per-row CRUD actions",
          "file_count": 1,
          "files": [
            "frontend/src/views/SourcesView.tsx:1-278"
          ],
          "sample_file": "frontend/src/views/SourcesView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/SourcesView.tsx",
              "start_line": 200,
              "end_line": 215,
              "snippet": "return (\n  <div>\n    <div className=\"view-header stagger-in\">\n      <h2>Enforcement Sources</h2>\n      <div className=\"view-desc\">...</div>\n    </div>\n    <ErrorBanner error={error} onDismiss={clearError} />\n    <div className=\"metrics-row stagger-in\">\n      <div className=\"metric-card\">...</div>\n      ...\n    </div>\n    <div className=\"panel stagger-in\">...</div>\n  </div>\n)"
            }
          ],
          "implementation_details": "6 inline sub-components (StatusBadge, StatusIcon, SourceExpandedDetail, SourceRowActions, SourceRow, AddSourceForm). SourcesView is the only view that inlines its MetricsRow rather than extracting it as a named component. Per-row expand state is LOCAL to SourceRow."
        }
      ],
      "analysis": "This is the highest-value finding from semantic cluster-001. Every async-action view independently implements the same 5-part scaffold: (1) view-header with h2 + view-desc, (2) ErrorBanner from useAsyncAction, (3) MetricsRow as an inline component computing .filter().length from store selectors, (4) panel containers with panel-header + action buttons + panel-body, (5) data tables with expandable rows. The scaffold accounts for ~60% of each view's code. Adding a new view requires copy-pasting an existing one and modifying the domain-specific parts, which propagates any structural issues. Purpose statements confirm these views serve different data domains but share identical UI orchestration \u2014 cluster semantic score 0.44 is driven by shared imports (0.75) and behavior (0.84), not just co-location.",
      "recommendation": "Extract a ViewShell component to components/ that provides the view-header + ErrorBanner + metrics slot + children layout. Extract a MetricCard component (the .metric-card div with label + value is repeated 16 times across 5 views). Extract an ActionButton component wrapping the run('key', fn) + disabled={!!busy} + conditional label pattern. Each view reduces from ~300 lines to ~100 lines of domain-specific content composed into the shell.",
      "evidence_quality": "high",
      "status": "completed",
      "cluster_id": "cluster-001"
    },
    {
      "id": "tree-hierarchy-duplication",
      "name": "Tree Hierarchy Rendering Duplication",
      "type": "semantic",
      "description": "Semantic cluster-004 (similarity 0.43) identifies 3 views that independently implement the same concept: 'render hierarchical data as an expandable tree with keyboard-accessible nodes, visual connectors, and severity badges.' DetectionView builds a 3-level fixed hierarchy with Set<string> expand state. PredictionView builds dynamic-depth trees from parent_step_id references with CSS custom property indentation. PolicyExplorer builds arbitrary-depth trees from nested objects with local per-node state. Each implements its own toggle logic, keyboard handler, connector CSS, and depth-based styling \u2014 the same functional machinery built 3 times.",
      "impact": "HIGH",
      "total_files": 3,
      "variants": [
        {
          "name": "detection-tree",
          "description": "DetectionView \u2014 3-level fixed hierarchy (tree \u2192 steps \u2192 patterns) with Set<string> multi-expand and ::before CSS connectors",
          "file_count": 1,
          "files": [
            "frontend/src/views/DetectionView.tsx:1-363"
          ],
          "sample_file": "frontend/src/views/DetectionView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/DetectionView.tsx",
              "start_line": 86,
              "end_line": 110,
              "snippet": "function TreePanel({ group, isExpanded, onToggle, expandedSteps, onToggleStep, expandedPatterns, onTogglePattern }: {...}) {\n  return (\n    <div className=\"panel stagger-in\">\n      <div className=\"panel-header clickable\" role=\"button\" tabIndex={0}\n        onClick={() => onToggle(group.tree_id)}\n        onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onToggle(group.tree_id); } }}>\n        <div className=\"detection-header-left\">\n          {isExpanded ? <ChevronDown size={16}/> : <ChevronRight size={16}/>}\n          <h3>{group.policy_name}</h3>\n        </div>\n      </div>\n      {isExpanded && <div className=\"panel-body panel-body-bordered\"><div className=\"detection-steps\">...</div></div>}\n    </div>\n  );\n}"
            },
            {
              "file": "frontend/src/views/DetectionView.tsx",
              "start_line": 274,
              "end_line": 280,
              "snippet": "function toggleSet(prev: Set<string>, id: string) {\n  const next = new Set(prev);\n  next.has(id) ? next.delete(id) : next.add(id);\n  return next;\n}"
            }
          ],
          "implementation_details": "3 inline sub-components (TreePanel, StepRow, PatternBlock). 3 independent Set<string> states for each tree level. Local toggleSet() utility. Expand-all/collapse-all buttons. CSS: .detection-step::before horizontal branch connector, border-left vertical line, margin-left indentation. Priority pills with color-mix(). Lucide chevron icons."
        },
        {
          "name": "prediction-tree",
          "description": "PredictionView \u2014 dynamic-depth tree from parent_step_id with CSS custom property --step-depth for indentation",
          "file_count": 1,
          "files": [
            "frontend/src/views/PredictionView.tsx:1-207"
          ],
          "sample_file": "frontend/src/views/PredictionView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/PredictionView.tsx",
              "start_line": 30,
              "end_line": 55,
              "snippet": "function StepNode({ step, depth, isExpanded, onToggle }: {...}) {\n  const hasDetail = [step.description, step.actor_action, step.enabling_qualities?.length].some(Boolean);\n  return (\n    <div className=\"tree-step\" style={{ '--step-depth': depth } as React.CSSProperties}>\n      <div className={`tree-step-content${hasDetail ? ' clickable' : ''}`}\n        role={hasDetail ? 'button' : undefined}\n        tabIndex={hasDetail ? 0 : undefined}\n        onClick={hasDetail ? () => onToggle(step.step_id) : undefined}\n        onKeyDown={hasDetail ? (e) => handleStepKeyDown(e, () => onToggle(step.step_id)) : undefined}>\n        <StepHeader step={step} isExpanded={isExpanded} />\n        {isExpanded && <StepDetail step={step} />}\n      </div>\n    </div>\n  );\n}"
            },
            {
              "file": "frontend/src/views/PredictionView.tsx",
              "start_line": 10,
              "end_line": 25,
              "snippet": "function buildStepTree(steps: ExploitationStep[]): { step: ExploitationStep; depth: number }[] {\n  const depthMap = new Map<string, number>();\n  const result: { step: ExploitationStep; depth: number }[] = [];\n  for (const step of steps) {\n    const parentDepth = step.parent_step_id ? (depthMap.get(step.parent_step_id) ?? 0) : 0;\n    const depth = step.parent_step_id ? parentDepth + 1 : 0;\n    depthMap.set(step.step_id, depth);\n    result.push({ step, depth });\n  }\n  return result;\n}"
            }
          ],
          "implementation_details": "4 inline sub-components (TreeCard, StepNode, StepHeader, StepDetail). 2 nullable string states (expandedTree, expandedStep). buildStepTree() computes depth from parent_step_id. CSS: .tree-step uses calc(var(--step-depth) * 24px + 8px) for indentation, ::before connectors at top: 50%. Shared handleStepKeyDown() utility. Conditional interactivity (only expand if step has detail)."
        },
        {
          "name": "policy-tree",
          "description": "PolicyExplorer \u2014 arbitrary-depth recursive tree from nested CatalogNode objects with per-node local expand state",
          "file_count": 1,
          "files": [
            "frontend/src/views/PolicyExplorer.tsx:1-225"
          ],
          "sample_file": "frontend/src/views/PolicyExplorer.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/PolicyExplorer.tsx",
              "start_line": 10,
              "end_line": 35,
              "snippet": "function TreeNode({ nodeKey, node, depth = 0, scannedPrograms = [] }: TreeNodeProps) {\n  const [expanded, setExpanded] = useState(depth < 2);\n  const isExpandable = !!node.children || !!node.programs;\n  return (\n    <div className={depth === 0 ? 'tree-node root' : 'tree-node'}>\n      <div className=\"tree-label\" role=\"button\" tabIndex={0}\n        onClick={() => setExpanded(!expanded)}\n        onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); setExpanded(!expanded); } }}>\n        <span className=\"tree-icon\">{treeIcon(isExpandable, expanded)}</span>\n        <span className={treeTextClass(depth)}>{node.label}</span>\n      </div>\n      {expanded && <TreeChildren node={node} depth={depth} ... />}\n    </div>\n  );\n}"
            }
          ],
          "implementation_details": "Recursive TreeNode component with local useState per node. Auto-expands first 2 levels. No global expand state. Padding-based indentation (no CSS connectors). Unicode icons (middle dot, triangles) instead of lucide. Depth-based font-weight via treeTextClass(). Split-view layout with ScanResultsTable and DataSourcesPanel on the right."
        }
      ],
      "analysis": "This is the second highest-value finding from semantic cluster-004. Three views implement the same functional concept \u2014 'render a collapsible tree' \u2014 with three different data models, three different expand state strategies, three different indentation systems, and three different icon systems. The shared kernel is: (a) a node with an expand toggle, (b) keyboard accessibility via Enter/Space, (c) depth-aware visual hierarchy, (d) conditional detail rendering when expanded. Purpose statements confirm different data domains but identical UI orchestration \u2014 cluster semantic score 0.42. The CSS duplication is a symptom: .detection-step and .tree-step both use ::before connectors with near-identical rules (differ only in top: 14px vs top: 50%), while .tree-node uses padding-only. A shared TreeNode primitive would eliminate ~400 lines of duplicated toggle/keyboard/connector logic and provide a template for future tree views.",
      "recommendation": "Extract a TreeNode component to components/ parameterized by: (a) expand state strategy (useToggleSet for multi-expand, useState for per-node, nullable for single-expand), (b) indentation mode (css-var depth, padding, or none), (c) connector style (::before lines or none), (d) icon set (lucide or unicode). Extract shared useTreeKeyHandler hook (identical Enter/Space handler in all 3). Unify CSS: create .tree-node-base with shared padding/cursor/transition, derive .detection-step and .tree-step from it.",
      "evidence_quality": "high",
      "status": "completed",
      "cluster_id": "cluster-004"
    },
    {
      "id": "data-display-view-duplication",
      "name": "Data Display View Duplication",
      "type": "semantic",
      "description": "Semantic cluster-002 (similarity 0.41) identifies 4 read-only views that independently implement the same concept: 'display a collection of items as cards or table rows with an expandable detail panel, keyboard accessibility, and store-driven data.' CaseSourcing and ConvergenceMatrix use data tables with expandable rows. DimensionRegistryView and TaxonomyView use card grids with select-to-expand. All 4 implement identical single-item toggle state (string|null + useCallback), identical keyboard handlers (Enter/Space), and identical detail panel layouts (.detail-grid 2-column). The card grid pattern (.quality-grid + .quality-card) is copy-pasted between DimensionRegistryView and TaxonomyView despite rendering different domain data with identical UI structure.",
      "impact": "MEDIUM",
      "total_files": 4,
      "variants": [
        {
          "name": "table-with-expand-rows",
          "description": "CaseSourcing + ConvergenceMatrix \u2014 data-table with expandable tbody rows via colSpan",
          "file_count": 2,
          "files": [
            "frontend/src/views/CaseSourcing.tsx:1-138",
            "frontend/src/views/ConvergenceMatrix.tsx:1-173"
          ],
          "sample_file": "frontend/src/views/CaseSourcing.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/CaseSourcing.tsx",
              "start_line": 15,
              "end_line": 40,
              "snippet": "function CaseRow({ caseData, isExpanded, onToggle, taxonomy }: {...}) {\n  return (\n    <>\n      <tr className=\"detail-row\" onClick={() => onToggle(caseData.case_id)}\n        tabIndex={0} role=\"button\"\n        onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onToggle(caseData.case_id); } }}>\n        <td>{isExpanded ? <ChevronDown/> : <ChevronRight/>}</td>\n        <td className=\"td-name\">{caseData.entity_name}</td>\n        ...\n      </tr>\n      {isExpanded && <tr><td colSpan={5} className=\"case-detail-cell\">\n        <div className=\"detail-expand\">...</div>\n      </td></tr>}\n    </>\n  );\n}"
            }
          ],
          "implementation_details": "Table rows toggle a sibling detail row via colSpan. CaseSourcing has CaseRow + SourceRegistry sub-components. ConvergenceMatrix has MatrixRow + MatrixCell + MatrixFooter. Both use .data-table CSS. Identical keyboard handler pattern."
        },
        {
          "name": "card-grid-with-detail",
          "description": "DimensionRegistryView + TaxonomyView \u2014 quality-grid card layout with select-to-detail pattern",
          "file_count": 2,
          "files": [
            "frontend/src/views/DimensionRegistryView.tsx:1-150",
            "frontend/src/views/TaxonomyView.tsx:1-117"
          ],
          "sample_file": "frontend/src/views/TaxonomyView.tsx",
          "code_excerpts": [
            {
              "file": "frontend/src/views/TaxonomyView.tsx",
              "start_line": 25,
              "end_line": 55,
              "snippet": "function QualityCard({ quality, isSelected, onSelect }: {...}) {\n  return (\n    <div className={`quality-card stagger-in${isSelected ? ' selected' : ''}`}\n      style={{ '--q-color': quality.color } as React.CSSProperties}\n      onClick={() => onSelect(quality.quality_id)}\n      tabIndex={0} role=\"button\"\n      onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onSelect(quality.quality_id); } }}>\n      <div className=\"quality-card-header\">...</div>\n      <div className=\"quality-card-def\">{quality.definition}</div>\n    </div>\n  );\n}"
            },
            {
              "file": "frontend/src/views/DimensionRegistryView.tsx",
              "start_line": 20,
              "end_line": 50,
              "snippet": "function DimensionCard({ dim, isExpanded, onToggle }: {...}) {\n  return (\n    <div className={`quality-card stagger-in${isExpanded ? ' selected' : ''}`}\n      onClick={() => onToggle(dim.dimension_id)}\n      tabIndex={0} role=\"button\"\n      onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onToggle(dim.dimension_id); } }}>\n      <div className=\"quality-card-header\">...</div>\n      {isExpanded && <div className=\"panel-expand-body\"><div className=\"detail-grid\">...</div></div>}\n    </div>\n  );\n}"
            }
          ],
          "implementation_details": "Both use .quality-grid CSS grid (auto-fill, minmax 280px). Both use .quality-card class with .selected state. DimensionRegistryView expands inline (panel-expand-body inside card). TaxonomyView shows detail panel below grid (QualityDetail component). Identical keyboard handlers. DimensionRegistryView reuses .quality-card despite rendering dimensions, not qualities \u2014 CSS class name mismatch."
        }
      ],
      "analysis": "Cluster-002 confirms these 4 views share behavioral signature (0.90) and import patterns (0.70). The card grid pair (DimensionRegistryView + TaxonomyView) is the clearest duplication \u2014 DimensionCard and QualityCard are structurally identical components with different prop names. DimensionRegistryView even reuses the .quality-card CSS class for dimensions, confirming it was copy-pasted from TaxonomyView. The table pair (CaseSourcing + ConvergenceMatrix) shares the data-table + expandable row pattern but diverges more in content structure. All 4 share the toggle state pattern (string|null + useCallback), the keyboard handler, and the detail-grid 2-column layout. Purpose statements distinguish the data domains but confirm identical UI purpose \u2014 'display a collection of domain entities with expandable detail.'",
      "recommendation": "Extract a CardGrid component to components/ that provides: quality-grid layout, click-to-select with keyboard handling, selected state styling, and a detail panel slot (inline or external). Extract a shared ExpandableRow component for the table pattern. Rename .quality-card to .item-card and .quality-grid to .item-grid since they're used for both qualities and dimensions. DimensionCard and QualityCard should become a single ItemCard component parameterized by render props for header and detail content.",
      "evidence_quality": "high",
      "status": "completed",
      "cluster_id": "cluster-002"
    }
  ]
}
